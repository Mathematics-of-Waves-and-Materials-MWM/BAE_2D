%%% input geometry for BAE problem
%%% two arrays connectivity and node_coords
% clear all

% input_geometry

% body_boundary = square;
% N_angles = 8;
%% a square 


%%%%% first we assemble a full square mesh with elements indexed in
%%%%% counterclockwise order

% size of the intial square/rectangular mesh

n_x = 200; 
n_y = 200; 

num_squares = n_x * n_y;

num_nodes = (n_x + 1) * (n_y + 1); 


node_coords = zeros(num_nodes , 2); 
cur_num_node = 0; 

   for y_idx = 0: n_y 
       for x_idx = 0:n_x
          cur_num_node = cur_num_node+1;  
           node_coords(cur_num_node , :) = [x_idx,y_idx];
       end
   end 

node_coords = node_coords - [100,100];   


connectivity = zeros(num_squares , 4); 
cur_num_square = 0; 


   for y_idx = 1:n_y
       for x_idx = 1:n_x
            cur_num_square = cur_num_square + 1;            
            n1 = (y_idx-1) * (n_x + 1) + x_idx; 
            n2 = (y_idx-1) * (n_x + 1) + x_idx + 1;
            n3 = (y_idx  ) * (n_x + 1) + x_idx + 1; 
            n4 = (y_idx  ) * (n_x + 1) + x_idx; 
            connectivity(cur_num_square , :) = [n1,n2,n3,n4];          
       end
   end



   % %%%% initial square grid
   % figure;
   % patch('Faces', connectivity, 'Vertices', node_coords, ...
   %    'FaceColor', 'none', ...        % No face fill
   %    'EdgeColor', 'k');              % Black edges

%axis equal;       % Keep aspect ratio

 %%% then the part of the grid that fall inside the obstacle boundary is
 %%% removed. If the obstacle is infinitely thin than a cut is made along
 %%% the boundary of the obstacle which disconnects the square elements on
 %%% different sides of the obstacle
 %%% The elements and nodes importart for BAE are indexed. They are
 %%% adjacent connectivities, boundary nodes and adjacent nodes

 % mask_squares = false(num_squares,1);
 % mask_boundary = false(1,num_nodes);
 % mask_adjacent_squares = false(num_squares,1);
 % inner_nodes = false(1,num_nodes);
 % outer_nodes = true(num_nodes,1);

 %%%%%% Let us go over each obstacle one by one

 for l_cur = 1:length(geometry)


     cur_mask_squares = false(num_squares,1);
     cur_mask_boundary = false(1,num_nodes);
     cur_mask_adjacent_squares = false(num_squares,1);
     cur_mask_inner_nodes = false(1,num_nodes);
     cur_mask_outer_nodes = true(num_nodes,1);

     body_boundary = geometry{l_cur};

     for n_cur = 1:num_nodes
         cur_node = node_coords(n_cur,:);
         cur_state= is_inside_boundary(cur_node,body_boundary);
         cur_mask_inner_nodes(n_cur) = cur_state;
         if (cur_state)
             connectivity_dist = abs(connectivity - n_cur);
             connectivity_dist = min(connectivity_dist,[],2);
             cur_mask_squares = cur_mask_squares|connectivity_dist<0.5;
         end
     end
    
    %figure; plot(node_coords(mask_inner_nodes,1),node_coords(mask_inner_nodes,2),'*')
    
    %mask_adjacent_squares = ~mask_squares;
    
    
     boundary_idx_ar = zeros(1,size(body_boundary,1));
    
     for n_cur = 1: size(body_boundary,1)
        cur_node = body_boundary(n_cur,:);
        dist2 = (node_coords(:,1) - cur_node(1)).^2 + (node_coords(:,2) - cur_node(2)).^2;
        [~,idx] = min(dist2);
        boundary_idx_ar(n_cur) = idx;
        cur_mask_boundary(idx) = true;
        connectivity_dist = abs(connectivity - idx);
        connectivity_dist = min(connectivity_dist,[],2);
        cur_mask_adjacent_squares = cur_mask_adjacent_squares|connectivity_dist<0.5;
     end
     cur_mask_adjacent_squares = cur_mask_adjacent_squares&~cur_mask_squares;
     cur_mask_adjacent_boundary = connectivity(cur_mask_adjacent_squares,:);
     cur_mask_adjacent_boundary = unique(mask_adjacent_boundary(:));
    
    
    
    
    cur_mask_outer_nodes(cur_mask_inner_nodes) = false(1,1);
    
    connectivity = connectivity(~cur_mask_squares,:);
    
    
    %%%%% spliting nodes for infinitely thin  obstacles (like a strip, for example)
    
    node_splitting



 end

node_coords_boundary = node_coords(cur_mask_boundary,:);
node_coords_adjacent = node_coords(mask_adjacent_boundary,:);
node_coords_outer = node_coords(cur_mask_outer_nodes,:);
num_nodes_boundary = size(node_coords_boundary,1);
num_nodes_outer = size(node_coords_outer,1);
num_nodes_adjacent = size(node_coords_adjacent,1);

   %%%% updated grid
   figure;
    patch('Faces', connectivity, 'Vertices', node_coords, ...
       'FaceColor', 'none', ...        % No face fill
       'EdgeColor', 'k');              % Black edges
 
 axis equal;       % Keep aspect ratio

   hold all
   plot(node_coords(cur_mask_boundary,1),node_coords(cur_mask_boundary,2),'r*')
   hold all
   plot(node_coords(cur_mask_outer_nodes,1),node_coords(cur_mask_outer_nodes,2),'bx')
   hold all
   plot(node_coords(mask_adjacent_boundary,1),node_coords(mask_adjacent_boundary,2),'go')

 % save("mesh.mat", 'connectivity','node_coords','mask_boundary','num_nodes','mask_outer_nodes','mask_adjacent_boundary',...
 %     "node_coords_boundary","num_nodes_boundary", "num_nodes_outer","node_coords_adjacent",...
 %     "node_coords_outer","num_nodes_adjacent",'N_angles')



 %%% remove elements from the grid to get a square


% 
% for n_cur = 1:num_squares
%     cur_nodes = connectivity(n_cur,:);
%     cur_coords = node_coords(cur_nodes,:);
%     maskx1 = cur_coords(:,1)>1.5&cur_coords(:,1)<8.5;
%     masky1 = cur_coords(:,2)>1.5&cur_coords(:,2)<8.5;
%     if sum(maskx1&masky1)>0
%     mask_squares(n_cur,:) = false(1,1);
%     mask_inner_nodes = [mask_inner_nodes,cur_nodes];
%     else
%     maskx2 = cur_coords(:,1)>0.5&cur_coords(:,1)<9.5;
%     masky2 = cur_coords(:,2)>0.5&cur_coords(:,2)<9.5;
%     mask_boundary = [mask_boundary,cur_nodes(maskx2&masky2)];
%     if(~isempty(cur_nodes(maskx2&masky2)))
%     mask_adjacent_boundary = [mask_adjacent_boundary,cur_nodes];
%     end
%     end
% end